<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<div id="app">
    <p ref="p1"></p>
    <ul>
        <li v-for="(item,index) in ary" :key="index" ref="itemList">{{item}}</li>
    </ul>
    <cxk :outerary="ary" @change-ary="changeAry"></cxk>
    <lhs></lhs>
</div>
<script src="./vue.js"></script>
<script>
  
    // 1. Vue实例的生命周期
    // beforeCreate() 数据观测尚未完成,不能通过this访问数据
    // created() 数据观测完成,可以通过this访问数据,尚未开启挂载, this.$el不可见, 可以发送ajax请求
    // beforeMount 把模板编译成虚拟DOM,在挂载前调用该钩子,this.$el可见,但是里面都是模板,并没有数据
    // mounted 把虚拟DOM挂载在真实的DOM元素上,此时访问this.$el 是绑定数据以后DOM元素,在mounted中也可以发送ajax请求数据,这里可以获取DOM元素和操作DOM 
    // beforeUpdate() 数据发生改变的时候会触发这个钩子,在视图更新之前调用
    // updated 数据更新导致视图更新,在视图更新后调用该钩子
    // beforeDestory() 在实例销毁前调用,此时实例中所有的数据都可用,如果页面中有定时器,在这个钩子中清除
    // destoryed() 在实例销毁后调用,此时实例中的数据不再是响应式,再修改数据,视图不会再更新了

    // 2. ref和 DOM操作
    // Vue是数据驱动,不提倡操作DOM,但是有些场景必须操作DOM, vue为我们提供了一些获取DOM的方式,在mounted中操作DOM
    // this.$refs.p1  , this.$refs.listItem

    // 3. 当数据发生改变时,Vue是异步更新视图,如果想获取数据更新以后的DOM, 需要使用 $nextTick()方法
    // this.$nextTick(callback) callback会在DOM更新以后执行(如果想要在DOM更新后操作DOM,或者在DOM更新后有其他的事情,需要用nextTick)

    // 4. 组件
    // Vue.component('组件名',config); 创建全局组件,全局组件不需要注册,只要创建,在任何实例中都可以用, config是创建Vue实例的配置对象
    // 每个组件都是Vue的实例, data/computed/methods/filters/watch/template/生命周期的钩子 这些属性每个组件都可以有
    
    // 5.局部组件
    // 创建组件 => 注册组件 => 使用组件
    // 组件是一个完整的功能单元,它可以由自己的html,组件的template就是组件私有的html
    let cxk = {
        template: `<div>CXK: <span v-for="(item,index) in ary " :key="index" @click="fn">{{item}}: {{outerary}}</span></div>`,
        data(){
            return {
                ary : [
                    'SING',
                    'DANCE',
                    'RAP'
                ]
            }
        },
        props:['outerary'],
        methods:{
            fn(){
                // console.log(this.outerary);
                this.$emit('change-ary',9);
            }
        }
    };
    let lhs = new Vue({
        template: `<div>啥牌子 vs LXS </div>`,
        data(){
            return {

            }
        }
    });
    let vm = new Vue({
        el :'#app',
        data: {
            ary : [1,4,5,2]
        },
        components: {
            // 使用局部组件要注册
            cxk, // 子组件
            lhs
        },
        methods:{
            changeAry(val){
                this.ary.push(val);
            }
        }
    });

    // 组件通信: (组件之间传递数据就叫组件通信)
    // 父传子: props 
    // 单项数据流: 数据只能从父组件流向子组件,子组件不能直接父组件的数据
    // 子传父: 通过事件机制,当子组件想要修改数据时,通知父组件,组件修改,父组件修改后,子组件就拿到最新的数据
</script>
</body>
</html>